---
interface Props {
  totalItems: number;
  itemsPerPage?: number;
  currentPage?: number;
  showInfo?: boolean;
}

const { 
  totalItems, 
  itemsPerPage = 12, 
  currentPage = 1,
  showInfo = true 
} = Astro.props;

const totalPages = Math.ceil(totalItems / itemsPerPage);
const startItem = (currentPage - 1) * itemsPerPage + 1;
const endItem = Math.min(currentPage * itemsPerPage, totalItems);
---

<div class="flex flex-col sm:flex-row items-center justify-between gap-4 mt-8">
  <!-- Results Info -->
  {showInfo && (
    <div class="text-sm text-grey order-2 sm:order-1">
      <span id="pagination-info">
        Mostrando <span class="font-medium text-black" id="start-item">{startItem}</span> a 
        <span class="font-medium text-black" id="end-item">{endItem}</span> de 
        <span class="font-medium text-black" id="total-items">{totalItems}</span> propiedades
      </span>
    </div>
  )}

  <!-- Pagination Controls -->
  <nav class="flex items-center space-x-2 order-1 sm:order-2" aria-label="Paginaci칩n">
    <!-- Previous Button -->
    <button
      id="prev-page"
      class="pagination-btn px-3 py-2 text-sm font-medium text-grey hover:text-black hover:bg-gray-50 rounded-md transition-colors duration-300 disabled:opacity-50 disabled:cursor-not-allowed"
      disabled={currentPage <= 1}
      aria-label="P치gina anterior"
    >
      <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
        <path fill-rule="evenodd" d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z" clip-rule="evenodd"></path>
      </svg>
      <span class="hidden sm:inline ml-1">Anterior</span>
    </button>

    <!-- Page Numbers -->
    <div id="page-numbers" class="flex items-center space-x-1">
      <!-- Page numbers will be generated by JavaScript -->
    </div>

    <!-- Next Button -->
    <button
      id="next-page"
      class="pagination-btn px-3 py-2 text-sm font-medium text-grey hover:text-black hover:bg-gray-50 rounded-md transition-colors duration-300 disabled:opacity-50 disabled:cursor-not-allowed"
      disabled={currentPage >= totalPages}
      aria-label="P치gina siguiente"
    >
      <span class="hidden sm:inline mr-1">Siguiente</span>
      <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
        <path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd"></path>
      </svg>
    </button>
  </nav>

  <!-- Items per page selector -->
  <div class="flex items-center space-x-2 text-sm order-3 sm:order-3">
    <label for="items-per-page" class="text-grey">Mostrar:</label>
    <select
      id="items-per-page"
      class="border border-gray-300 rounded-md px-2 py-1 text-black bg-white focus:outline-none focus:ring-2 focus:ring-black focus:border-transparent"
    >
      <option value="12" selected={itemsPerPage === 12}>12</option>
      <option value="24" selected={itemsPerPage === 24}>24</option>
      <option value="36" selected={itemsPerPage === 36}>36</option>
      <option value="48" selected={itemsPerPage === 48}>48</option>
    </select>
    <span class="text-grey">por p치gina</span>
  </div>
</div>

<style>
  .pagination-btn:disabled {
    pointer-events: none;
  }
  
  .page-number {
    padding: 0.5rem 0.75rem;
    font-size: 0.875rem;
    font-weight: 500;
    border-radius: 0.375rem;
    transition: color 0.3s ease, background-color 0.3s ease;
    cursor: pointer;
  }
  
  .page-number.active {
    background-color: black;
    color: white;
  }
  
  .page-number:not(.active) {
    color: #6b7280;
  }
  
  .page-number:not(.active):hover {
    color: black;
    background-color: #f9fafb;
  }
  
  .page-ellipsis {
    padding: 0.5rem;
    font-size: 0.875rem;
    color: #6b7280;
    cursor: default;
  }
</style>

<script>
  class PaginationManager {
    private totalItems: number = 0;
    private itemsPerPage: number = 12;
    private currentPage: number = 1;
    private totalPages: number = 0;

    private prevButton: HTMLButtonElement | null = null;
    private nextButton: HTMLButtonElement | null = null;
    private pageNumbersContainer: HTMLElement | null = null;
    private itemsPerPageSelect: HTMLSelectElement | null = null;
    private startItemSpan: HTMLElement | null = null;
    private endItemSpan: HTMLElement | null = null;
    private totalItemsSpan: HTMLElement | null = null;

    constructor() {
      this.init();
    }

    private init() {
      // Get DOM elements
      this.prevButton = document.getElementById('prev-page') as HTMLButtonElement;
      this.nextButton = document.getElementById('next-page') as HTMLButtonElement;
      this.pageNumbersContainer = document.getElementById('page-numbers');
      this.itemsPerPageSelect = document.getElementById('items-per-page') as HTMLSelectElement;
      this.startItemSpan = document.getElementById('start-item');
      this.endItemSpan = document.getElementById('end-item');
      this.totalItemsSpan = document.getElementById('total-items');

      // Add event listeners
      this.addEventListeners();

      // Listen for property updates
      window.addEventListener('propertiesUpdated', this.handlePropertiesUpdated.bind(this));
    }

    private addEventListeners() {
      // Previous/Next buttons
      this.prevButton?.addEventListener('click', () => this.goToPage(this.currentPage - 1));
      this.nextButton?.addEventListener('click', () => this.goToPage(this.currentPage + 1));

      // Items per page change
      this.itemsPerPageSelect?.addEventListener('change', (e) => {
        const target = e.target as HTMLSelectElement;
        this.setItemsPerPage(parseInt(target.value));
      });
    }

    private handlePropertiesUpdated(event: any) {
      const { totalItems, filteredItems } = event.detail;
      this.updatePagination(filteredItems || totalItems);
    }

    public updatePagination(totalItems: number) {
      this.totalItems = totalItems;
      this.totalPages = Math.ceil(totalItems / this.itemsPerPage);
      
      // Reset to page 1 if current page is beyond available pages
      if (this.currentPage > this.totalPages && this.totalPages > 0) {
        this.currentPage = 1;
      }
      
      this.updateDisplay();
      this.updatePageNumbers();
      this.updateButtonStates();
      
      // Emit page change event
      this.emitPageChangeEvent();
    }

    private updateDisplay() {
      if (!this.totalItemsSpan || !this.startItemSpan || !this.endItemSpan) return;

      const startItem = (this.currentPage - 1) * this.itemsPerPage + 1;
      const endItem = Math.min(this.currentPage * this.itemsPerPage, this.totalItems);

      this.totalItemsSpan.textContent = this.totalItems.toString();
      this.startItemSpan.textContent = this.totalItems > 0 ? startItem.toString() : '0';
      this.endItemSpan.textContent = this.totalItems > 0 ? endItem.toString() : '0';
    }

    private updatePageNumbers() {
      if (!this.pageNumbersContainer) return;

      this.pageNumbersContainer.innerHTML = '';

      if (this.totalPages <= 1) return;

      const maxVisiblePages = 5;
      let startPage = Math.max(1, this.currentPage - Math.floor(maxVisiblePages / 2));
      let endPage = Math.min(this.totalPages, startPage + maxVisiblePages - 1);

      // Adjust start page if we're near the end
      if (endPage - startPage < maxVisiblePages - 1) {
        startPage = Math.max(1, endPage - maxVisiblePages + 1);
      }

      // Add first page and ellipsis if needed
      if (startPage > 1) {
        this.createPageButton(1);
        if (startPage > 2) {
          this.createEllipsis();
        }
      }

      // Add page numbers
      for (let i = startPage; i <= endPage; i++) {
        this.createPageButton(i);
      }

      // Add ellipsis and last page if needed
      if (endPage < this.totalPages) {
        if (endPage < this.totalPages - 1) {
          this.createEllipsis();
        }
        this.createPageButton(this.totalPages);
      }
    }

    private createPageButton(pageNumber: number) {
      const button = document.createElement('button');
      button.className = `page-number ${pageNumber === this.currentPage ? 'active' : ''}`;
      button.textContent = pageNumber.toString();
      button.addEventListener('click', () => this.goToPage(pageNumber));
      this.pageNumbersContainer?.appendChild(button);
    }

    private createEllipsis() {
      const ellipsis = document.createElement('span');
      ellipsis.className = 'page-ellipsis';
      ellipsis.textContent = '...';
      this.pageNumbersContainer?.appendChild(ellipsis);
    }

    private updateButtonStates() {
      if (this.prevButton) {
        this.prevButton.disabled = this.currentPage <= 1;
      }
      if (this.nextButton) {
        this.nextButton.disabled = this.currentPage >= this.totalPages;
      }
    }

    private goToPage(page: number) {
      if (page < 1 || page > this.totalPages) return;
      
      this.currentPage = page;
      this.updateDisplay();
      this.updatePageNumbers();
      this.updateButtonStates();
      this.emitPageChangeEvent();
      
      // Scroll to top of results
      const resultsContainer = document.getElementById('property-results');
      if (resultsContainer) {
        resultsContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
    }

    private setItemsPerPage(itemsPerPage: number) {
      this.itemsPerPage = itemsPerPage;
      this.currentPage = 1; // Reset to first page
      this.updatePagination(this.totalItems);
    }

    private emitPageChangeEvent() {
      const pageChangeEvent = new CustomEvent('pageChange', {
        detail: {
          currentPage: this.currentPage,
          itemsPerPage: this.itemsPerPage,
          startIndex: (this.currentPage - 1) * this.itemsPerPage,
          endIndex: Math.min(this.currentPage * this.itemsPerPage, this.totalItems)
        }
      });
      window.dispatchEvent(pageChangeEvent);
    }

    // Public methods for external control
    public getCurrentPage(): number {
      return this.currentPage;
    }

    public getItemsPerPage(): number {
      return this.itemsPerPage;
    }

    public getTotalPages(): number {
      return this.totalPages;
    }
  }

  // Initialize pagination when DOM is loaded
  document.addEventListener('DOMContentLoaded', function() {
    window.paginationManager = new PaginationManager();
  });

  // Make PaginationManager available globally
  declare global {
    interface Window {
      paginationManager: PaginationManager;
    }
  }
</script>